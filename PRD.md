# PDF-A-go-slim — Product Requirements Document

## Overview

A browser-based PDF optimization tool that reduces file size without requiring server-side processing. Runs entirely in the browser using JavaScript/WebAssembly. No uploads, no accounts, no file size limits beyond available RAM.

## Origin Story

This project grew out of [PDF-A-go-go](https://github.com/khawkins98/PDF-A-go-go), an embeddable PDF viewer for the web. While building a 3-page showcase PDF for the project's demo page, we hit a problem that turns out to be universal:

A clean 32KB PDF generated by ReportLab was opened in Adobe Illustrator for a small layout tweak. Illustrator saved it back at 198KB — a 6x increase for a cosmetic change. What happened? Illustrator silently embedded full TrueType copies of Helvetica and Courier (standard fonts every PDF reader already has), added a 10KB JPEG thumbnail nobody asked for, injected layers of AI-private metadata, and duplicated font references in multiple formats.

We tried the obvious tools:
- **Ghostscript** got it to 96KB but couldn't strip the redundant standard font embeddings
- **qpdf** barely moved the needle (194KB) — it optimizes structure but doesn't touch content
- **iLovePDF** (online) got it to 62KB — good result, but you're uploading your file to a third-party server and paying for batch use
- **Smallpdf** — paywalled before you can even try

This is a solved problem in theory — every optimization technique is well-documented — but there's no tool that puts them all together in the browser where your files stay private and the tool is free.

## The Problem

PDF bloat is everywhere and nobody has a good answer:

- **Creative tools are the worst offenders.** Illustrator, InDesign, Photoshop, Canva, and Google Slides all embed unnecessary fonts, duplicate objects, and inject application-private metadata. A simple "Save As PDF" routinely doubles or triples the file size.
- **Desktop software** (Adobe Acrobat, Ghostscript) can fix this but isn't always installed. Ghostscript is powerful but CLI-only and its flags are arcane (`-dPDFSETTINGS=/screen -dCompatibilityLevel=1.4`).
- **Online services** (iLovePDF, Smallpdf) work but require uploading your files to a third party. They're paywalled for batch or large files. For institutional users with sensitive documents, uploading isn't an option.
- **Command-line tools** (qpdf, mutool) need installation and only handle structural optimization, not content-level cleanup like font deduplication or image recompression.

There's no open-source, privacy-first, in-browser option that handles the full range of optimizations.

## Core Value Proposition

- **No upload** — files never leave the browser
- **No install** — works in any modern browser tab
- **Free and open source** — MIT licensed
- **Batch capable** — drag in multiple PDFs, optimize all at once

## Target Users

1. **Content publishers** — bloggers, documentation writers who need lean PDFs for the web
2. **Developers** — embedding PDFs in apps, need to minimize transfer size
3. **Institutional users** — universities, governments with privacy-sensitive documents they can't upload to third-party services

## Features

### P0 — MVP

| Feature | Description |
|---------|-------------|
| **Drag-and-drop input** | Drop one or more PDFs onto the page, or use a file picker |
| **Stream recompression** | Decompress and recompress all streams with optimal Flate settings |
| **Remove duplicate objects** | Deduplicate identical streams (fonts, images referenced multiple times) |
| **Strip metadata bloat** | Remove application-private data (Illustrator `AIPrivateData`, Photoshop `IRB`, XMP thumbnails) while preserving user-facing metadata (title, author, subject) |
| **Font deduplication** | Detect when the same font is embedded multiple times (e.g., TrueType subset + Type1 reference for standard fonts) and keep only what's needed |
| **Unreferenced object removal** | Delete objects not reachable from the document catalog |
| **Size comparison** | Show before/after file size with percentage reduction |
| **Download output** | One-click download of optimized PDF(s), or batch zip |
| **Lossless by default** | All P0 optimizations are lossless — visual output is identical |

### P1 — Enhanced

| Feature | Description |
|---------|-------------|
| **Image recompression** | Re-encode raster images at user-chosen quality (JPEG quality slider, WebP where supported) |
| **Image downsampling** | Reduce image DPI to target (e.g., 150 DPI for screen, 300 DPI for print) |
| **Font subsetting** | Subset embedded fonts to only include glyphs actually used in the document |
| **Standard font unembedding** | Remove embedded copies of the 14 standard PDF fonts (Helvetica, Courier, Times, etc.) since all PDF readers include them |
| **Linearization** | Rewrite for fast web viewing (byte-serving, page-at-a-time loading) |
| **Optimization presets** | Named profiles: "Web" (aggressive), "Print" (conservative), "Archive" (lossless maximum) |
| **Side-by-side preview** | Render before/after pages to verify no visual regression |

### P2 — Power User

| Feature | Description |
|---------|-------------|
| **Object inspector** | Tree view of the PDF structure showing each object's type and size contribution |
| **Per-object control** | Toggle individual optimizations (e.g., keep this image at full resolution) |
| **CLI / Node.js mode** | Same core engine usable as an npm package for build pipelines |
| **Watch mode (Node)** | Watch a directory and auto-optimize PDFs on save |
| **WASM Ghostscript fallback** | For operations that can't be done with pure JS parsing, use a WASM-compiled Ghostscript |

## Technical Architecture

### Core Engine

```
pdf-a-go-slim/
  src/
    parser/          # PDF object/stream parser (cross-ref tables, object streams)
    optimizer/
      streams.js     # Stream recompression (Flate, LZW → Flate)
      dedup.js       # Object deduplication (content-hash based)
      metadata.js    # Metadata stripping (AI, XMP thumbnails, etc.)
      fonts.js       # Font dedup, subsetting, standard font unembedding
      images.js      # Image recompression and downsampling
      unreferenced.js # Unreferenced object removal
    writer/          # PDF serializer (cross-ref rebuild, linearization)
    index.js         # Pipeline: parse → optimize → write
```

### Key Technical Decisions

**PDF Parsing**: Build on [pdf-lib](https://github.com/Hopding/pdf-lib) for low-level PDF object manipulation, or write a minimal parser. pdf-lib handles cross-reference tables, object streams, and incremental updates but doesn't do optimization. An alternative is [pdfjs-dist](https://github.com/nicbou/pdf.js) for rendering-side validation but it's read-only.

**Stream Compression**: Use [pako](https://github.com/nicbou/pako) (zlib in JS) for Flate recompression. Most PDFs use Flate already but often with suboptimal compression levels.

**Font Subsetting**: Use [fontkit](https://github.com/nicbou/fontkit) or [subset-font](https://github.com/nicbou/subset-font) for TrueType/OpenType subsetting in the browser.

**Image Processing**: Use OffscreenCanvas + Canvas API for image re-encoding (JPEG, PNG). For WebP, use the browser's native encoder via `canvas.toBlob('image/webp', quality)`.

**WASM Option**: For maximum compression, compile [MuPDF](https://mupdf.com/) or Ghostscript to WASM. This handles edge cases (Type1 font conversion, JBIG2 recompression) that pure JS can't. Ship as an optional heavy module (~5MB).

### Browser Constraints

| Constraint | Mitigation |
|------------|------------|
| **Memory** | Process pages/objects incrementally via streaming; don't load entire PDF into memory at once for large files |
| **No filesystem** | Use File API for input, Blob URLs for output, IndexedDB for temp storage during batch operations |
| **Single thread** | Offload compression to Web Workers; use `SharedArrayBuffer` where available for zero-copy transfer |
| **No native zlib** | pako is ~95% as fast as native zlib; CompressionStream API (Chrome 80+) is native-speed alternative |

### Node.js Mode

The same core engine runs in Node.js with:
- `fs` instead of File API for I/O
- Native `zlib` instead of pako
- Optional native font tools (harfbuzz) for faster subsetting

Publish as:
```
npm install pdf-a-go-slim       # Core engine (browser + Node)
npx pdf-a-go-slim ./input.pdf   # CLI usage
```

## UI Design

### Layout

Single-page app. Three states:

1. **Empty** — Large drop zone with "Drop PDFs here" message + file picker button
2. **Processing** — File list with progress bars per file, overall progress
3. **Results** — File list showing original size → optimized size (% saved), download buttons

### Controls

- **Optimization level**: Simple toggle — "Lossless" (default) vs "Lossy"
- **Lossy settings** (expandable): Image quality slider (1-100), target DPI dropdown
- **Advanced** (expandable): Individual toggle switches for each optimization type
- **Batch actions**: "Download All" (zip), "Download All" (individual)

### Responsive

Works on mobile for quick single-file optimization. Batch features are desktop-focused.

## Success Metrics

| Metric | Target |
|--------|--------|
| Average lossless reduction | 20-40% on typical PDFs |
| Processing speed (10MB PDF) | < 5 seconds in browser |
| Bundle size (core) | < 200KB gzipped |
| Bundle size (with WASM) | < 5MB |
| Browser support | Chrome 80+, Firefox 90+, Safari 15+, Edge 80+ |

## Competitive Landscape

| Tool | Runs locally | Free | Open source | Batch | Font optimization |
|------|:---:|:---:|:---:|:---:|:---:|
| **PDF-A-go-slim** | Yes (browser) | Yes | Yes | Yes | Yes |
| iLovePDF | No (upload) | Freemium | No | Paid | Yes |
| Smallpdf | No (upload) | Freemium | No | Paid | Yes |
| Ghostscript | Yes (CLI) | Yes | Yes | Yes | Yes |
| qpdf | Yes (CLI) | Yes | Yes | Yes | No |
| pdf-lib | Yes (JS) | Yes | Yes | N/A | No (library only) |

## Open Questions

1. **pdf-lib vs custom parser?** pdf-lib is well-maintained but may not expose enough internals for font deduplication and stream-level manipulation. May need to fork or write a lower-level parser.
2. **WASM Ghostscript licensing**: Ghostscript is AGPL. Using it as an optional WASM module loaded at runtime (not bundled) may be acceptable, but needs legal review. MuPDF is also AGPL. Alternative: compile [QPDF](https://github.com/qpdf/qpdf) (Apache 2.0) to WASM.
3. **Standard font unembedding safety**: Some PDF readers on mobile/embedded systems may not have the base-14 fonts. Should this be behind a warning?
