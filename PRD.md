# PDF-A-go-slim — Product Requirements Document

## Overview

A browser-based PDF optimization tool that reduces file size without requiring server-side processing. Runs entirely in the browser using JavaScript/WebAssembly. No uploads, no accounts, no file size limits beyond available RAM.

## Origin Story

This project grew out of [PDF-A-go-go](https://github.com/khawkins98/PDF-A-go-go), an embeddable PDF viewer for the web. While building a 3-page showcase PDF for the project's demo page, we hit a problem that turns out to be universal:

A clean 32KB PDF generated by ReportLab was opened in Adobe Illustrator for a small layout tweak. Illustrator saved it back at 198KB — a 6x increase for a cosmetic change. What happened? Illustrator silently embedded full TrueType copies of Helvetica and Courier (standard fonts every PDF reader already has), added a 10KB JPEG thumbnail nobody asked for, injected layers of AI-private metadata, and duplicated font references in multiple formats.

We tried the obvious tools:
- **Ghostscript** got it to 96KB but couldn't strip the redundant standard font embeddings
- **qpdf** barely moved the needle (194KB) — it optimizes structure but doesn't touch content
- **iLovePDF** (online) got it to 62KB — good result, but you're uploading your file to a third-party server and paying for batch use
- **Smallpdf** — paywalled before you can even try

This is a solved problem in theory — every optimization technique is well-documented — but there's no tool that puts them all together in the browser where your files stay private and the tool is free.

## The Problem

PDF bloat is everywhere and nobody has a good answer:

- **Creative tools are the worst offenders.** Illustrator, InDesign, Photoshop, Canva, and Google Slides all embed unnecessary fonts, duplicate objects, and inject application-private metadata. A simple "Save As PDF" routinely doubles or triples the file size.
- **Desktop software** (Adobe Acrobat, Ghostscript) can fix this but isn't always installed. Ghostscript is powerful but CLI-only and its flags are arcane (`-dPDFSETTINGS=/screen -dCompatibilityLevel=1.4`).
- **Online services** (iLovePDF, Smallpdf) work but require uploading your files to a third party. They're paywalled for batch or large files. For institutional users with sensitive documents, uploading isn't an option.
- **Command-line tools** (qpdf, mutool) need installation and only handle structural optimization, not content-level cleanup like font deduplication or image recompression.

There's no open-source, privacy-first, in-browser option that handles the full range of optimizations.

## Core Value Proposition

- **No upload** — files never leave the browser
- **No install** — works in any modern browser tab
- **Free and open source** — MIT licensed
- **Batch capable** — drag in multiple PDFs, optimize all at once

## Target Users

1. **Content publishers** — bloggers, documentation writers who need lean PDFs for the web
2. **Developers** — embedding PDFs in apps, need to minimize transfer size
3. **Institutional users** — universities, governments with privacy-sensitive documents they can't upload to third-party services

## Features

### P0 — MVP

| Feature | Description |
|---------|-------------|
| **Drag-and-drop input** | Drop one or more PDFs onto the page, or use a file picker |
| **Stream recompression** | Decompress and recompress all streams with optimal Flate settings |
| **Remove duplicate objects** | Deduplicate identical streams (fonts, images referenced multiple times) |
| **Strip metadata bloat** | Remove application-private data (Illustrator `AIPrivateData`, Photoshop `IRB`, XMP thumbnails) while preserving user-facing metadata (title, author, subject) |
| **Font deduplication** | Detect when the same font is embedded multiple times (e.g., TrueType subset + Type1 reference for standard fonts) and keep only what's needed |
| **Unreferenced object removal** | Delete objects not reachable from the document catalog |
| **Size comparison** | Show before/after file size with percentage reduction |
| **Download output** | One-click download of optimized PDF(s), or batch zip |
| **Lossless by default** | All P0 optimizations are lossless — visual output is identical |

### P1 — Enhanced

| Feature | Description |
|---------|-------------|
| **Image recompression** | Re-encode raster images at user-chosen quality (JPEG quality slider, WebP where supported) |
| **Image downsampling** | Reduce image DPI to target (e.g., 150 DPI for screen, 300 DPI for print) |
| **Font subsetting** | Subset embedded fonts to only include glyphs actually used in the document |
| **Standard font unembedding** | Remove embedded copies of the 14 standard PDF fonts (Helvetica, Courier, Times, etc.) since all PDF readers include them |
| **Linearization** | Rewrite for fast web viewing (byte-serving, page-at-a-time loading) |
| **Optimization presets** | Named profiles: "Web" (aggressive), "Print" (conservative), "Archive" (lossless maximum) |
| **Side-by-side preview** | Render before/after pages using [PDF-A-go-go](https://github.com/khawkins98/PDF-A-go-go) to verify no visual regression |
| **Re-optimize** | After results, offer a button to re-run with different settings (e.g., try Lossy after seeing Lossless results) without starting over |
| **Optimization summary** | Show a human-readable summary of what was done (e.g., "3 images recompressed, 1 font unembedded, 12 metadata entries stripped") |
| **Credits & attribution** | Footer or about section crediting open-source packages used (pdf-lib, fflate, jpeg-js, PDF-A-go-go) and linking to source |

### P2 — Power User

| Feature | Description |
|---------|-------------|
| **Object inspector** | Tree view of the PDF structure showing each object's type and size contribution |
| **Per-object control** | Toggle individual optimizations (e.g., keep this image at full resolution) |
| **CLI / Node.js mode** | Same core engine usable as an npm package for build pipelines |
| **Watch mode (Node)** | Watch a directory and auto-optimize PDFs on save |
| **WASM Ghostscript fallback** | For operations that can't be done with pure JS parsing, use a WASM-compiled Ghostscript |

## Technical Architecture

### Core Engine (as built)

```
src/
  main.js                     # UI, drag-and-drop, worker orchestration
  worker.js                   # Web Worker — off-main-thread processing
  engine/
    pipeline.js               # Sequential optimization passes with progress + options
    optimize/
      streams.js              # Recompress streams with fflate level 9
      images.js               # FlateDecode → JPEG recompression (lossy, opt-in)
      font-unembed.js         # Remove embedded base-14 standard fonts
      font-subset.js          # Subset embedded fonts via harfbuzzjs WASM
      dedup.js                # Hash-based object deduplication (djb2)
      fonts.js                # Consolidate duplicate embedded fonts
      metadata.js             # Strip XMP, Illustrator, Photoshop bloat keys
      unreferenced.js         # Remove unreachable objects via BFS traversal
    utils/
      accessibility-detect.js # PDF/A, PDF/UA, tagged PDF detection
      hash.js                 # Shared hashing (hashBytes) + font constants (FONT_FILE_KEYS)
      stream-decode.js        # Decoders: Flate, LZW, ASCII85, ASCIIHex, RunLength, PNG prediction
      pdf-traversal.js        # BFS graph walker from PDF trailer
      content-stream-parser.js # Extract char codes per font from content streams
      unicode-mapper.js       # Map char codes → Unicode codepoints
      glyph-list.js           # Adobe Glyph List + standard encoding tables
      harfbuzz-subsetter.js   # harfbuzzjs WASM wrapper for font subsetting
```

### Options Schema

All passes receive an `options` object. Each pass checks its own flags and ignores unknown options, making the schema forward-compatible with presets and per-pass configurability.

```js
{
  lossy: false,                  // Master switch for lossy optimizations (default off)
  imageQuality: 0.85,            // JPEG quality 0-1 (only when lossy=true)
  maxImageDpi: undefined,        // Downsample images above this DPI (only when lossy=true)
  unembedStandardFonts: true,    // Remove embedded base-14 fonts (default on, lossless)
  subsetFonts: true,             // Subset embedded fonts to used glyphs (default on, lossless)
}
```

### Key Technical Decisions

**PDF Parsing**: [pdf-lib](https://github.com/Hopding/pdf-lib) for low-level PDF object access (PDFDocument, PDFDict, PDFArray, PDFRawStream, etc.). Provides cross-reference tables, object streams, and incremental updates. We operate directly on its internal context objects for optimization.

**Stream Compression**: [fflate](https://github.com/101arrowz/fflate) — pure-JS zlib for deflateSync/inflateSync. Faster and smaller than pako. Used for both stream recompression and PNG prediction reversal.

**Image Recompression**: [jpeg-js](https://github.com/jpeg-js/jpeg-js) — pure JS JPEG encoder/decoder (~15KB). Works in both Web Worker and Node (for tests). Chosen over OffscreenCanvas because OffscreenCanvas isn't available in Node test environments.

**Font Unembedding**: Type1 and TrueType only. Type0/CIDFont composites use 2-byte Identity-H encoding — unembedding would require rewriting content stream text operators, which is too risky. Fonts with custom `/Encoding << /Differences [...] >>` are also skipped.

**Font Subsetting**: [harfbuzzjs](https://github.com/nicbou/harfbuzzjs) WASM (~596 KB gzipped) for TrueType/OpenType subsetting. We call the C API directly (`hb_subset_or_fail`) rather than using the JS wrapper (which has CJS/ESM interop issues — see `docs/learnings.md`). Supports Type1/TrueType (simple, 1-byte char codes via Encoding/Differences → Adobe Glyph List) and Type0/Identity-H (2-byte CIDs via ToUnicode CMap, with `retain-gids` to preserve CID=GID mapping). WASM is lazy-loaded as a separate Vite chunk.

**Future considerations for image processing**: OffscreenCanvas + Canvas API could enable WebP encoding (`canvas.toBlob('image/webp', quality)`) in browsers that support it.

**WASM Option**: For maximum compression, compile [QPDF](https://github.com/qpdf/qpdf) (Apache 2.0) to WASM. MuPDF and Ghostscript are AGPL — licensing concerns for bundling. Ship as an optional heavy module (~5MB).

### Browser Constraints

| Constraint | Mitigation |
|------------|------------|
| **Memory** | Process pages/objects incrementally via streaming; don't load entire PDF into memory at once for large files |
| **No filesystem** | Use File API for input, Blob URLs for output, IndexedDB for temp storage during batch operations |
| **Single thread** | Offload compression to Web Workers; use `SharedArrayBuffer` where available for zero-copy transfer |
| **No native zlib** | pako is ~95% as fast as native zlib; CompressionStream API (Chrome 80+) is native-speed alternative |

### Node.js Mode

The same core engine runs in Node.js with:
- `fs` instead of File API for I/O
- Native `zlib` instead of pako
- Optional native font tools (harfbuzz) for faster subsetting

Publish as:
```
npm install pdf-a-go-slim       # Core engine (browser + Node)
npx pdf-a-go-slim ./input.pdf   # CLI usage
```

## UI Design

### Layout

Single-page app. Three states:

1. **Empty** — Large drop zone with "Drop PDFs here" message + file picker button
2. **Processing** — File list with progress bars per file, overall progress
3. **Results** — File list showing original size → optimized size (% saved), download buttons

### Controls

- **Optimization level**: Simple toggle — "Lossless" (default) vs "Lossy"
- **Lossy settings** (expandable): Image quality slider (1-100), target DPI dropdown
- **Advanced** (expandable): Individual toggle switches for each optimization type
- **Presets** (future): Named profiles ("Web", "Print", "Archive") that set all options at once, with the ability to customize individual settings within a preset
- **Batch actions**: "Download All" (zip), "Download All" (individual)

### Responsive

Works on mobile for quick single-file optimization. Batch features are desktop-focused.

## Success Metrics

| Metric | Target |
|--------|--------|
| Average lossless reduction | 20-40% on typical PDFs |
| Processing speed (10MB PDF) | < 5 seconds in browser |
| Bundle size (core) | < 200KB gzipped |
| Bundle size (with WASM) | < 5MB |
| Browser support | Chrome 80+, Firefox 90+, Safari 15+, Edge 80+ |

## Competitive Landscape

| Tool | Runs locally | Free | Open source | Batch | Font optimization |
|------|:---:|:---:|:---:|:---:|:---:|
| **PDF-A-go-slim** | Yes (browser) | Yes | Yes | Yes | Yes |
| iLovePDF | No (upload) | Freemium | No | Paid | Yes |
| Smallpdf | No (upload) | Freemium | No | Paid | Yes |
| Ghostscript | Yes (CLI) | Yes | Yes | Yes | Yes |
| qpdf | Yes (CLI) | Yes | Yes | Yes | No |
| pdf-lib | Yes (JS) | Yes | Yes | N/A | No (library only) |

## Progress

### P0 — MVP
- [x] Drag-and-drop input
- [x] Stream recompression (Flate level 9)
- [x] Remove duplicate objects (hash-based dedup)
- [x] Strip metadata bloat (XMP, Illustrator, Photoshop)
- [x] Font deduplication
- [x] Unreferenced object removal (BFS traversal)
- [x] Size comparison (before/after display)
- [x] Download output
- [x] Lossless by default
- [x] Web Worker for off-main-thread processing

### P1 — Enhanced (in progress)
- [x] Image recompression (FlateDecode → JPEG via jpeg-js, lossy opt-in)
- [x] Image downsampling (area-average box filter, DPI-aware via page map; Web=150, Print=300)
- [x] Standard font unembedding (14 base fonts, Type1/TrueType only)
- [x] Optimization presets (Lossless / Web / Print) with UI controls
- [x] Optimization summary (per-pass stats in expandable detail rows)
- [x] Re-optimize button (re-run with different settings from results screen)
- [x] Credits & attribution (footer with package links)
- [x] Font subsetting (harfbuzzjs WASM, Type1/TrueType + Type0/Identity-H, retain-gids)
- [ ] Linearization
- [ ] Side-by-side preview (via PDF-A-go-go)

### P2 — Power User
- [ ] Object inspector
- [ ] Per-object control
- [ ] CLI / Node.js mode
- [ ] Watch mode (Node)
- [ ] WASM Ghostscript fallback

## Accessibility & PDF/A Considerations

PDF optimization can degrade accessibility. The following mitigations are in place and planned:

### Already addressed

- **ToUnicode CMap preservation** — `font-unembed.js` preserves `/ToUnicode` entries when replacing standard font dicts, so screen readers retain glyph-to-character mapping.
- **Document language migration** — `metadata.js` extracts `dc:language` from XMP and sets `/Lang` on the catalog before stripping XMP, preserving the language tag for assistive technology.
- **Dedup safety** — `dedup.js` only deduplicates `PDFRawStream` objects. Structure tree elements (`/StructElem`) are plain `PDFDict` objects and are never merged.
- **Tagged PDF detection** — `accessibility-detect.js` detects `/MarkInfo` and `/StructTreeRoot` on the catalog. Traits are reported in `stats.pdfTraits` for UI visibility.
- **PDF/A awareness** — Pipeline auto-detects PDF/A conformance level (via XMP `pdfaid:part`) and disables font unembedding and XMP stripping for PDF/A files. Bloat keys are still stripped.
- **Structure tree protection** — Confirmed via tests that `unreferenced.js` BFS traversal reaches `/StructTreeRoot` and its descendants through the catalog. Tagged structure is never removed as orphaned.
- **XMP accessibility metadata** — `parseConformanceFromXmp()` detects `pdfuaid:part` (PDF/UA) and `pdfaid:part`/`pdfaid:conformance` (PDF/A). XMP is preserved for PDF/A files.
- **Accessible PDF test suite** — Test fixtures for tagged PDFs, PDF/A-1b, PDF/A-2b, PDF/UA, and tagged PDFs with orphans. End-to-end pipeline tests verify accessibility data survives optimization.
- **PDF/A-1 object stream protection** — Pipeline conditionally disables `useObjectStreams` when `pdfALevel` starts with `1`, preserving strict PDF/A-1 conformance. PDF/A-2+ files still use object streams for better compression.
- **PDF/UA font protection** — Font unembedding is blocked for PDF/UA documents (`isPdfUA` triggers skip), matching the PDF/A behavior. Ensures all fonts remain embedded as required by ISO 14289.

### Future work

| Item | Priority | Description |
|------|----------|-------------|
| **UI accessibility warnings** | P3 | Surface `pdfTraits` in the results UI to warn users when they're optimizing tagged/PDF-A/PDF-UA documents. Show the detected conformance level (e.g., "PDF/A-1b detected — font unembedding and XMP removal disabled"). |

## Learnings & Documentation

Technical learnings, design decisions, and pitfalls encountered during development are captured in [`docs/learnings.md`](docs/learnings.md). This is a living document — update it whenever we discover something non-obvious about PDF internals, tooling trade-offs, or browser constraints.

## Open Questions

1. ~~**pdf-lib vs custom parser?**~~ **Resolved:** pdf-lib works well. Direct access to its internal `context` and indirect object enumeration provides sufficient low-level control for all current optimization passes without needing a fork.
2. **WASM Ghostscript licensing**: Ghostscript is AGPL. MuPDF is also AGPL. Best alternative: compile [QPDF](https://github.com/qpdf/qpdf) (Apache 2.0) to WASM for structural optimizations that pure JS can't handle.
3. ~~**Standard font unembedding safety**~~ **Resolved:** Implemented for Type1/TrueType only, skipping Type0 composites and fonts with custom Differences encodings. Enabled by default (`unembedStandardFonts: true`) since all conforming PDF readers are required to provide the base-14 fonts.
4. ~~**Configurability UX**~~ **Resolved:** Implemented preset buttons (Lossless/Web/Print), collapsible Advanced Settings panel with lossy/lossless toggle, image quality slider, and font unembedding checkbox. Presets set all controls; manual tweaks auto-detect matching preset or show "Custom". Options flow through to the worker and engine unchanged.
